// This file is generated by /utils/generate_types/index.js


import type { APIRequestContext, Browser, BrowserContext, BrowserContextOptions, Page, LaunchOptions, ViewportSize, Geolocation, HTTPCredentials, Locator, APIResponse, PageScreenshotOptions } from 'playwright-core';
export * from 'playwright-core';

export type BlobReporterOptions = { outputDir?: string, fileName?: string };
export type ListReporterOptions = { printSteps?: boolean };
export type JUnitReporterOptions = { outputFile?: string, stripANSIControlSequences?: boolean, includeProjectInTestName?: boolean };
export type JsonReporterOptions = { outputFile?: string };
export type HtmlReporterOptions = { outputFolder?: string, open?: 'always' | 'never' | 'on-failure', host?: string, port?: number, attachmentsBaseURL?: string, title?: string, noSnippets?: boolean };

export type ReporterDescription = Readonly<
  ['blob'] | ['blob', BlobReporterOptions] |
  ['dot'] |
  ['line'] |
  ['list'] | ['list', ListReporterOptions] |
  ['github'] |
  ['junit'] | ['junit', JUnitReporterOptions] |
  ['json'] | ['json', JsonReporterOptions] |
  ['html'] | ['html', HtmlReporterOptions] |
  ['null'] |
  [string] | [string, any]
>;

type UseOptions<TestArgs, WorkerArgs> = Partial<WorkerArgs> & Partial<TestArgs>;


interface TestProject<TestArgs = {}, WorkerArgs = {}> {
  
  use?: UseOptions<TestArgs, WorkerArgs>;
  
  dependencies?: Array<string>;

  
  expect?: {
    
    timeout?: number;

    
    toHaveScreenshot?: {
      
      threshold?: number;

      
      maxDiffPixels?: number;

      
      maxDiffPixelRatio?: number;

      
      animations?: "allow"|"disabled";

      
      caret?: "hide"|"initial";

      
      scale?: "css"|"device";

      
      stylePath?: string|Array<string>;

      
      pathTemplate?: string;
    };

    
    toMatchAriaSnapshot?: {
      
      pathTemplate?: string;
    };

    
    toMatchSnapshot?: {
      
      threshold?: number;

      
      maxDiffPixels?: number;

      
      maxDiffPixelRatio?: number;
    };

    
    toPass?: {
      
      timeout?: number;

      
      intervals?: Array<number>;
    };
  };

  
  fullyParallel?: boolean;

  
  grep?: RegExp|Array<RegExp>;

  
  grepInvert?: RegExp|Array<RegExp>;

  
  ignoreSnapshots?: boolean;

  
  metadata?: Metadata;

  
  name?: string;

  
  outputDir?: string;

  
  repeatEach?: number;

  
  respectGitIgnore?: boolean;

  
  retries?: number;

  
  snapshotDir?: string;

  
  snapshotPathTemplate?: string;

  
  teardown?: string;

  
  testDir?: string;

  
  testIgnore?: string|RegExp|Array<string|RegExp>;

  
  testMatch?: string|RegExp|Array<string|RegExp>;

  
  timeout?: number;

  
  workers?: number|string;
}

export interface Project<TestArgs = {}, WorkerArgs = {}> extends TestProject<TestArgs, WorkerArgs> {
}


export interface FullProject<TestArgs = {}, WorkerArgs = {}> {
  
  use: UseOptions<PlaywrightTestOptions & TestArgs, PlaywrightWorkerOptions & WorkerArgs>;
  
  dependencies: Array<string>;

  
  grep: RegExp|Array<RegExp>;

  
  grepInvert: null|RegExp|Array<RegExp>;

  
  metadata: Metadata;

  
  name: string;

  
  outputDir: string;

  
  repeatEach: number;

  
  retries: number;

  
  snapshotDir: string;

  
  teardown?: string;

  
  testDir: string;

  
  testIgnore: string|RegExp|Array<string|RegExp>;

  
  testMatch: string|RegExp|Array<string|RegExp>;

  
  timeout: number;
}

type LiteralUnion<T extends U, U = string> = T | (U & { zz_IGNORE_ME?: never });


interface TestConfig<TestArgs = {}, WorkerArgs = {}> {
  
  projects?: Project<TestArgs, WorkerArgs>[];
  
  reporter?: LiteralUnion<'list'|'dot'|'line'|'github'|'json'|'junit'|'null'|'html', string> | ReporterDescription[];
  
  use?: UseOptions<TestArgs, WorkerArgs>;
  
  webServer?: TestConfigWebServer | TestConfigWebServer[];
  
  build?: {
    
    external?: Array<string>;
  };

  
  captureGitInfo?: {
    
    commit?: boolean;

    
    diff?: boolean;
  };

  
  expect?: {
    
    timeout?: number;

    
    toHaveScreenshot?: {
      
      animations?: "allow"|"disabled";

      
      caret?: "hide"|"initial";

      
      maxDiffPixels?: number;

      
      maxDiffPixelRatio?: number;

      
      scale?: "css"|"device";

      
      stylePath?: string|Array<string>;

      
      threshold?: number;

      
      pathTemplate?: string;
    };

    
    toMatchAriaSnapshot?: {
      
      pathTemplate?: string;
    };

    
    toMatchSnapshot?: {
      
      maxDiffPixels?: number;

      
      maxDiffPixelRatio?: number;

      
      threshold?: number;
    };

    
    toPass?: {
      
      intervals?: Array<number>;

      
      timeout?: number;
    };
  };

  
  failOnFlakyTests?: boolean;

  
  forbidOnly?: boolean;

  
  fullyParallel?: boolean;

  
  globalSetup?: string|Array<string>;

  
  globalTeardown?: string|Array<string>;

  
  globalTimeout?: number;

  
  grep?: RegExp|Array<RegExp>;

  
  grepInvert?: RegExp|Array<RegExp>;

  
  ignoreSnapshots?: boolean;

  
  maxFailures?: number;

  
  metadata?: Metadata;

  
  name?: string;

  
  outputDir?: string;

  
  preserveOutput?: "always"|"never"|"failures-only";

  
  quiet?: boolean;

  
  repeatEach?: number;

  
  reportSlowTests?: null|{
    
    max: number;

    
    threshold: number;
  };

  
  respectGitIgnore?: boolean;

  
  retries?: number;

  
  shard?: null|{
    
    current: number;

    
    total: number;
  };

  
  snapshotDir?: string;

  
  snapshotPathTemplate?: string;

  
  testDir?: string;

  
  testIgnore?: string|RegExp|Array<string|RegExp>;

  
  testMatch?: string|RegExp|Array<string|RegExp>;

  
  timeout?: number;

  
  tsconfig?: string;

  
  updateSnapshots?: "all"|"changed"|"missing"|"none";

  
  updateSourceMethod?: "overwrite"|"3way"|"patch";

  
  workers?: number|string;
}

export interface Config<TestArgs = {}, WorkerArgs = {}> extends TestConfig<TestArgs, WorkerArgs> {
}

export type Metadata = { [key: string]: any };


export interface FullConfig<TestArgs = {}, WorkerArgs = {}> {
  
  projects: FullProject<TestArgs, WorkerArgs>[];
  
  reporter: ReporterDescription[];
  
  webServer: TestConfigWebServer | null;
  
  configFile?: string;

  
  forbidOnly: boolean;

  
  fullyParallel: boolean;

  
  globalSetup: null|string;

  
  globalTeardown: null|string;

  
  globalTimeout: number;

  
  grep: RegExp|Array<RegExp>;

  
  grepInvert: null|RegExp|Array<RegExp>;

  
  maxFailures: number;

  
  metadata: Metadata;

  
  preserveOutput: "always"|"never"|"failures-only";

  
  quiet: boolean;

  
  reportSlowTests: null|{
    
    max: number;

    
    threshold: number;
  };

  
  rootDir: string;

  
  shard: null|{
    
    total: number;

    
    current: number;
  };

  
  updateSnapshots: "all"|"changed"|"missing"|"none";

  
  updateSourceMethod: "overwrite"|"3way"|"patch";

  
  version: string;

  
  workers: number;
}


export interface TestInfo {
  
  snapshotPath(...name: ReadonlyArray<string>): string;
  
  snapshotPath(name: string, options: { kind: 'snapshot' | 'screenshot' | 'aria' }): string;
  
  attach(name: string, options?: {
    
    body?: string|Buffer;

    
    contentType?: string;

    
    path?: string;
  }): Promise<void>;

  
  fail(): void;

  
  fail(condition: boolean, description?: string): void;

  
  fixme(): void;

  
  fixme(condition: boolean, description?: string): void;

  
  outputPath(...pathSegments: ReadonlyArray<string>): string;

  
  setTimeout(timeout: number): void;

  
  skip(): void;

  
  skip(condition: boolean, description?: string): void;

  
  slow(): void;

  
  slow(condition: boolean, description?: string): void;

  
  annotations: Array<{
    
    type: string;

    
    description?: string;

    
    location?: Location;
  }>;

  
  attachments: Array<{
    
    name: string;

    
    contentType: string;

    
    path?: string;

    
    body?: Buffer;
  }>;

  
  column: number;

  
  config: FullConfig;

  
  duration: number;

  
  error?: TestInfoError;

  
  errors: Array<TestInfoError>;

  
  expectedStatus: "passed"|"failed"|"timedOut"|"skipped"|"interrupted";

  
  file: string;

  
  fn: Function;

  
  line: number;

  
  outputDir: string;

  
  parallelIndex: number;

  
  project: FullProject;

  
  repeatEachIndex: number;

  
  retry: number;

  
  snapshotDir: string;

  
  snapshotSuffix: string;

  
  status?: "passed"|"failed"|"timedOut"|"skipped"|"interrupted";

  
  tags: Array<string>;

  
  testId: string;

  
  timeout: number;

  
  title: string;

  
  titlePath: Array<string>;

  
  workerIndex: number;
}

export type TestStatus = 'passed' | 'failed' | 'timedOut' | 'skipped' | 'interrupted';

export type TestDetailsAnnotation = {
  type: string;
  description?: string;
};

export type TestAnnotation = TestDetailsAnnotation & {
  location?: Location;
};

export type TestDetails = {
  tag?: string | string[];
  annotation?: TestDetailsAnnotation | TestDetailsAnnotation[];
}

type TestBody<TestArgs> = (args: TestArgs, testInfo: TestInfo) => Promise<void> | void;
type ConditionBody<TestArgs> = (args: TestArgs) => boolean;


export interface TestType<TestArgs extends {}, WorkerArgs extends {}> {
  
  (title: string, body: TestBody<TestArgs & WorkerArgs>): void;
  
  (title: string, details: TestDetails, body: TestBody<TestArgs & WorkerArgs>): void;

  
  only(title: string, body: TestBody<TestArgs & WorkerArgs>): void;
  
  only(title: string, details: TestDetails, body: TestBody<TestArgs & WorkerArgs>): void;

  
  describe: {
    
    (title: string, callback: () => void): void;
    
    (callback: () => void): void;
    
    (title: string, details: TestDetails, callback: () => void): void;

    
    only(title: string, callback: () => void): void;
    
    only(callback: () => void): void;
    
    only(title: string, details: TestDetails, callback: () => void): void;

    
    skip(title: string, callback: () => void): void;
    
    skip(callback: () => void): void;
    
    skip(title: string, details: TestDetails, callback: () => void): void;

    
    fixme(title: string, callback: () => void): void;
    
    fixme(callback: () => void): void;
    
    fixme(title: string, details: TestDetails, callback: () => void): void;

    
    serial: {
      
      (title: string, callback: () => void): void;
      
      (callback: () => void): void;
      
      (title: string, details: TestDetails, callback: () => void): void;

      
      only(title: string, callback: () => void): void;
      
      only(callback: () => void): void;
      
      only(title: string, details: TestDetails, callback: () => void): void;
    };

    
    parallel: {
      
      (title: string, callback: () => void): void;
      
      (callback: () => void): void;
      
      (title: string, details: TestDetails, callback: () => void): void;

      
      only(title: string, callback: () => void): void;
      
      only(callback: () => void): void;
      
      only(title: string, details: TestDetails, callback: () => void): void;
    };

    
    configure: (options: { mode?: 'default' | 'parallel' | 'serial', retries?: number, timeout?: number }) => void;
  };

  
  skip(title: string, body: TestBody<TestArgs & WorkerArgs>): void;
  
  skip(title: string, details: TestDetails, body: TestBody<TestArgs & WorkerArgs>): void;
  
  skip(): void;
  
  skip(condition: boolean, description?: string): void;
  
  skip(callback: ConditionBody<TestArgs & WorkerArgs>, description?: string): void;

  
  fixme(title: string, body: TestBody<TestArgs & WorkerArgs>): void;
  
  fixme(title: string, details: TestDetails, body: TestBody<TestArgs & WorkerArgs>): void;
  
  fixme(): void;
  
  fixme(condition: boolean, description?: string): void;
  
  fixme(callback: ConditionBody<TestArgs & WorkerArgs>, description?: string): void;

  
  fail: {
    
    (title: string, body: TestBody<TestArgs & WorkerArgs>): void;
    
    (title: string, details: TestDetails, body: TestBody<TestArgs & WorkerArgs>): void;
    
    (condition: boolean, description?: string): void;
    
    (callback: ConditionBody<TestArgs & WorkerArgs>, description?: string): void;
    
    (): void;

    
    only(title: string, body: TestBody<TestArgs & WorkerArgs>): void;
    
    only(title: string, details: TestDetails, body: TestBody<TestArgs & WorkerArgs>): void;
  }

  
  slow(): void;
  
  slow(condition: boolean, description?: string): void;
  
  slow(callback: ConditionBody<TestArgs & WorkerArgs>, description?: string): void;

  
  setTimeout(timeout: number): void;
  
  beforeEach(inner: (args: TestArgs & WorkerArgs, testInfo: TestInfo) => Promise<any> | any): void;
  
  beforeEach(title: string, inner: (args: TestArgs & WorkerArgs, testInfo: TestInfo) => Promise<any> | any): void;
  
  afterEach(inner: (args: TestArgs & WorkerArgs, testInfo: TestInfo) => Promise<any> | any): void;
  
  afterEach(title: string, inner: (args: TestArgs & WorkerArgs, testInfo: TestInfo) => Promise<any> | any): void;
  
  beforeAll(inner: (args: TestArgs & WorkerArgs, testInfo: TestInfo) => Promise<any> | any): void;
  
  beforeAll(title: string, inner: (args: TestArgs & WorkerArgs, testInfo: TestInfo) => Promise<any> | any): void;
  
  afterAll(inner: (args: TestArgs & WorkerArgs, testInfo: TestInfo) => Promise<any> | any): void;
  
  afterAll(title: string, inner: (args: TestArgs & WorkerArgs, testInfo: TestInfo) => Promise<any> | any): void;
  
  use(fixtures: Fixtures<{}, {}, TestArgs, WorkerArgs>): void;
  
  step: {
    
    <T>(title: string, body: (step: TestStepInfo) => T | Promise<T>, options?: { box?: boolean, location?: Location, timeout?: number }): Promise<T>;
    
    skip(title: string, body: (step: TestStepInfo) => any | Promise<any>, options?: { box?: boolean, location?: Location, timeout?: number }): Promise<void>;
  }
  
  expect: Expect<{}>;
  
  extend<T extends {}, W extends {} = {}>(fixtures: Fixtures<T, W, TestArgs, WorkerArgs>): TestType<TestArgs & T, WorkerArgs & W>;
  
  info(): TestInfo;
}

export type TestFixture<R, Args extends {}> = (args: Args, use: (r: R) => Promise<void>, testInfo: TestInfo) => any;
export type WorkerFixture<R, Args extends {}> = (args: Args, use: (r: R) => Promise<void>, workerInfo: WorkerInfo) => any;
type TestFixtureValue<R, Args extends {}> = Exclude<R, Function> | TestFixture<R, Args>;
type WorkerFixtureValue<R, Args extends {}> = Exclude<R, Function> | WorkerFixture<R, Args>;
export type Fixtures<T extends {} = {}, W extends {} = {}, PT extends {} = {}, PW extends {} = {}> = {
  [K in keyof PW]?: WorkerFixtureValue<PW[K], W & PW> | [WorkerFixtureValue<PW[K], W & PW>, { scope: 'worker', timeout?: number | undefined, title?: string, box?: boolean }];
} & {
  [K in keyof PT]?: TestFixtureValue<PT[K], T & W & PT & PW> | [TestFixtureValue<PT[K], T & W & PT & PW>, { scope: 'test', timeout?: number | undefined, title?: string, box?: boolean }];
} & {
  [K in Exclude<keyof W, keyof PW | keyof PT>]?: [WorkerFixtureValue<W[K], W & PW>, { scope: 'worker', auto?: boolean, option?: boolean, timeout?: number | undefined, title?: string, box?: boolean }];
} & {
  [K in Exclude<keyof T, keyof PW | keyof PT>]?: TestFixtureValue<T[K], T & W & PT & PW> | [TestFixtureValue<T[K], T & W & PT & PW>, { scope?: 'test', auto?: boolean, option?: boolean, timeout?: number | undefined, title?: string, box?: boolean }];
};

type BrowserName = 'chromium' | 'firefox' | 'webkit';
type BrowserChannel = Exclude<LaunchOptions['channel'], undefined>;
type ColorScheme = Exclude<BrowserContextOptions['colorScheme'], undefined>;
type ClientCertificate = Exclude<BrowserContextOptions['clientCertificates'], undefined>[0];
type ExtraHTTPHeaders = Exclude<BrowserContextOptions['extraHTTPHeaders'], undefined>;
type Proxy = Exclude<BrowserContextOptions['proxy'], undefined>;
type StorageState = Exclude<BrowserContextOptions['storageState'], undefined>;
type ServiceWorkerPolicy = Exclude<BrowserContextOptions['serviceWorkers'], undefined>;
type ConnectOptions = {
  
  wsEndpoint: string;

  
  headers?: { [key: string]: string; };

  
  exposeNetwork?: string;

  
  timeout?: number;
};


export interface PlaywrightWorkerOptions {
  
  browserName: BrowserName;
  defaultBrowserType: BrowserName;
  
  headless: boolean;
  
  channel: BrowserChannel | undefined;
  
  launchOptions: Omit<LaunchOptions, 'tracesDir'>;
  
  connectOptions: ConnectOptions | undefined;
  
  screenshot: ScreenshotMode | { mode: ScreenshotMode } & Pick<PageScreenshotOptions, 'fullPage' | 'omitBackground'>;
  
  trace: TraceMode |  'retry-with-trace' | { mode: TraceMode, snapshots?: boolean, screenshots?: boolean, sources?: boolean, attachments?: boolean };
  
  video: VideoMode |  'retry-with-video' | { mode: VideoMode, size?: ViewportSize };
}

export type ScreenshotMode = 'off' | 'on' | 'only-on-failure' | 'on-first-failure';
export type TraceMode = 'off' | 'on' | 'retain-on-failure' | 'on-first-retry' | 'on-all-retries' | 'retain-on-first-failure';
export type VideoMode = 'off' | 'on' | 'retain-on-failure' | 'on-first-retry';


export interface PlaywrightTestOptions {
  
  acceptDownloads: boolean;
  
  bypassCSP: boolean;
  
  colorScheme: ColorScheme;
  
  clientCertificates: ClientCertificate[] | undefined;
  
  deviceScaleFactor: number | undefined;
  
  extraHTTPHeaders: ExtraHTTPHeaders | undefined;
  
  geolocation: Geolocation | undefined;
  
  hasTouch: boolean;
  
  httpCredentials: HTTPCredentials | undefined;
  
  ignoreHTTPSErrors: boolean;
  
  isMobile: boolean;
  
  javaScriptEnabled: boolean;
  
  locale: string | undefined;
  
  offline: boolean;
  
  permissions: string[] | undefined;
  
  proxy: Proxy | undefined;
  
  storageState: StorageState | undefined;
  
  timezoneId: string | undefined;
  
  userAgent: string | undefined;
  
  viewport: ViewportSize | null;
  
  baseURL: string | undefined;
  
  contextOptions: BrowserContextOptions;
  
  actionTimeout: number;
  
  navigationTimeout: number;
  
  serviceWorkers: ServiceWorkerPolicy;
  
  testIdAttribute: string;
}



export interface PlaywrightWorkerArgs {
  playwright: typeof import('playwright-core');
  
  browser: Browser;
}


export interface PlaywrightTestArgs {
  
  context: BrowserContext;
  
  page: Page;
  
  request: APIRequestContext;
}

type ExcludeProps<A, B> = {
  [K in Exclude<keyof A, keyof B>]: A[K];
};
type CustomProperties<T> = ExcludeProps<T, PlaywrightTestOptions & PlaywrightWorkerOptions & PlaywrightTestArgs & PlaywrightWorkerArgs>;

export type PlaywrightTestProject<TestArgs = {}, WorkerArgs = {}> = Project<PlaywrightTestOptions & CustomProperties<TestArgs>, PlaywrightWorkerOptions & CustomProperties<WorkerArgs>>;
export type PlaywrightTestConfig<TestArgs = {}, WorkerArgs = {}> = Config<PlaywrightTestOptions & CustomProperties<TestArgs>, PlaywrightWorkerOptions & CustomProperties<WorkerArgs>>;

type AsymmetricMatcher = Record<string, any>;

interface AsymmetricMatchers {
  
  any(sample: unknown): AsymmetricMatcher;
  
  anything(): AsymmetricMatcher;
  
  arrayContaining(sample: Array<unknown>): AsymmetricMatcher;
  
  closeTo(sample: number, precision?: number): AsymmetricMatcher;
  
  objectContaining(sample: Record<string, unknown>): AsymmetricMatcher;
  
  stringContaining(sample: string): AsymmetricMatcher;
  
  stringMatching(sample: string | RegExp): AsymmetricMatcher;
}


interface GenericAssertions<R> {
  
  not: GenericAssertions<R>;
  
  toBe(expected: unknown): R;
  
  toBeCloseTo(expected: number, numDigits?: number): R;
  
  toBeDefined(): R;
  
  toBeFalsy(): R;
  
  toBeGreaterThan(expected: number | bigint): R;
  
  toBeGreaterThanOrEqual(expected: number | bigint): R;
  
  toBeInstanceOf(expected: Function): R;
  
  toBeLessThan(expected: number | bigint): R;
  
  toBeLessThanOrEqual(expected: number | bigint): R;
  
  toBeNaN(): R;
  
  toBeNull(): R;
  
  toBeTruthy(): R;
  
  toBeUndefined(): R;
  
  toContain(expected: string): R;
  
  toContain(expected: unknown): R;
  
  toContainEqual(expected: unknown): R;
  
  toEqual(expected: unknown): R;
  
  toHaveLength(expected: number): R;
  
  toHaveProperty(keyPath: string | Array<string>, value?: unknown): R;
  
  toMatch(expected: RegExp | string): R;
  
  toMatchObject(expected: Record<string, unknown> | Array<unknown>): R;
  
  toStrictEqual(expected: unknown): R;
  
  toThrow(error?: unknown): R;
  
  toThrowError(error?: unknown): R;

}

type FunctionAssertions = {
  
  toPass(options?: { timeout?: number, intervals?: number[] }): Promise<void>;
};

type BaseMatchers<R, T> = GenericAssertions<R> & PlaywrightTest.Matchers<R, T> & SnapshotAssertions;
type AllowedGenericMatchers<R, T> = PlaywrightTest.Matchers<R, T> & Pick<GenericAssertions<R>, 'toBe' | 'toBeDefined' | 'toBeFalsy' | 'toBeNull' | 'toBeTruthy' | 'toBeUndefined'>;

type SpecificMatchers<R, T> =
  T extends Page ? PageAssertions & AllowedGenericMatchers<R, T> :
  T extends Locator ? LocatorAssertions & AllowedGenericMatchers<R, T> :
  T extends APIResponse ? APIResponseAssertions & AllowedGenericMatchers<R, T> :
  BaseMatchers<R, T> & (T extends Function ? FunctionAssertions : {});
type AllMatchers<R, T> = PageAssertions & LocatorAssertions & APIResponseAssertions & FunctionAssertions & BaseMatchers<R, T>;

type IfAny<T, Y, N> = 0 extends (1 & T) ? Y : N;
type Awaited<T> = T extends PromiseLike<infer U> ? U : T;
type ToUserMatcher<F, DefaultReturnType> = F extends (first: any, ...args: infer Rest) => infer R ? (...args: Rest) => (R extends PromiseLike<infer U> ? Promise<void> : DefaultReturnType) : never;
type ToUserMatcherObject<T, DefaultReturnType, ArgType> = {
  [K in keyof T as T[K] extends (arg: ArgType, ...rest: any[]) => any ? K : never]: ToUserMatcher<T[K], DefaultReturnType>;
};

type MatcherHintColor = (arg: string) => string;

export type MatcherHintOptions = {
  comment?: string;
  expectedColor?: MatcherHintColor;
  isDirectExpectCall?: boolean;
  isNot?: boolean;
  promise?: string;
  receivedColor?: MatcherHintColor;
  secondArgument?: string;
  secondArgumentColor?: MatcherHintColor;
};

export interface ExpectMatcherUtils {
  matcherHint(matcherName: string, received: unknown, expected: unknown, options?: MatcherHintOptions): string;
  printDiffOrStringify(expected: unknown, received: unknown, expectedLabel: string, receivedLabel: string, expand: boolean): string;
  printExpected(value: unknown): string;
  printReceived(object: unknown): string;
  printWithType<T>(name: string, value: T, print: (value: T) => string): string;
  diff(a: unknown, b: unknown): string | null;
  stringify(object: unknown, maxDepth?: number, maxWidth?: number): string;
}

export type ExpectMatcherState = {
  
  isNot: boolean;
  
  promise: 'rejects' | 'resolves' | '';
  utils: ExpectMatcherUtils;
  
  timeout: number;
};

export type MatcherReturnType = {
  message: () => string;
  pass: boolean;
  name?: string;
  expected?: unknown;
  actual?: any;
  log?: string[];
  timeout?: number;
};

type MakeMatchers<R, T, ExtendedMatchers> = {
  
  not: MakeMatchers<R, T, ExtendedMatchers>;
  
  resolves: MakeMatchers<Promise<R>, Awaited<T>, ExtendedMatchers>;
  
  rejects: MakeMatchers<Promise<R>, any, ExtendedMatchers>;
} & IfAny<T, AllMatchers<R, T>, SpecificMatchers<R, T> & ToUserMatcherObject<ExtendedMatchers, R, T>>;

type PollMatchers<R, T, ExtendedMatchers> = {
  
  not: PollMatchers<R, T, ExtendedMatchers>;
} & BaseMatchers<R, T> & ToUserMatcherObject<ExtendedMatchers, R, T>;

export type Expect<ExtendedMatchers = {}> = {
  <T = unknown>(actual: T, messageOrOptions?: string | { message?: string }): MakeMatchers<void, T, ExtendedMatchers>;
  soft: <T = unknown>(actual: T, messageOrOptions?: string | { message?: string }) => MakeMatchers<void, T, ExtendedMatchers>;
  poll: <T = unknown>(actual: () => T | Promise<T>, messageOrOptions?: string | { message?: string, timeout?: number, intervals?: number[] }) => PollMatchers<Promise<void>, T, ExtendedMatchers>;
  extend<MoreMatchers extends Record<string, (this: ExpectMatcherState, receiver: any, ...args: any[]) => MatcherReturnType | Promise<MatcherReturnType>>>(matchers: MoreMatchers): Expect<ExtendedMatchers & MoreMatchers>;
  configure: (configuration: {
    message?: string,
    timeout?: number,
    soft?: boolean,
  }) => Expect<ExtendedMatchers>;
  getState(): unknown;
  not: Omit<AsymmetricMatchers, 'any' | 'anything'>;
} & AsymmetricMatchers;

// --- BEGINGLOBAL ---
declare global {
  export namespace PlaywrightTest {
    export interface Matchers<R, T = unknown> {
    }
  }
}
// --- ENDGLOBAL ---


export const test: TestType<PlaywrightTestArgs & PlaywrightTestOptions, PlaywrightWorkerArgs & PlaywrightWorkerOptions>;
export default test;

export const _baseTest: TestType<{}, {}>;
export const expect: Expect<{}>;


export function defineConfig(config: PlaywrightTestConfig): PlaywrightTestConfig;
export function defineConfig<T>(config: PlaywrightTestConfig<T>): PlaywrightTestConfig<T>;
export function defineConfig<T, W>(config: PlaywrightTestConfig<T, W>): PlaywrightTestConfig<T, W>;
export function defineConfig(config: PlaywrightTestConfig, ...configs: PlaywrightTestConfig[]): PlaywrightTestConfig;
export function defineConfig<T>(config: PlaywrightTestConfig<T>, ...configs: PlaywrightTestConfig<T>[]): PlaywrightTestConfig<T>;
export function defineConfig<T, W>(config: PlaywrightTestConfig<T, W>, ...configs: PlaywrightTestConfig<T, W>[]): PlaywrightTestConfig<T, W>;

type MergedT<List> = List extends [TestType<infer T, any>, ...(infer Rest)] ? T & MergedT<Rest> : {};
type MergedW<List> = List extends [TestType<any, infer W>, ...(infer Rest)] ? W & MergedW<Rest> : {};
type MergedTestType<List> = TestType<MergedT<List>, MergedW<List>>;


export function mergeTests<List extends any[]>(...tests: List): MergedTestType<List>;

type MergedExpectMatchers<List> = List extends [Expect<infer M>, ...(infer Rest)] ? M & MergedExpectMatchers<Rest> : {};
type MergedExpect<List> = Expect<MergedExpectMatchers<List>>;


export function mergeExpects<List extends any[]>(...expects: List): MergedExpect<List>;

// This is required to not export everything by default. See https://github.com/Microsoft/TypeScript/issues/19545#issuecomment-340490459
export { };




interface APIResponseAssertions {
  
  toBeOK(): Promise<void>;

  
  not: APIResponseAssertions;
}


interface LocatorAssertions {
  
  toBeAttached(options?: {
    attached?: boolean;

    
    timeout?: number;
  }): Promise<void>;

  
  toBeChecked(options?: {
    
    checked?: boolean;

    
    indeterminate?: boolean;

    
    timeout?: number;
  }): Promise<void>;

  
  toBeDisabled(options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toBeEditable(options?: {
    editable?: boolean;

    
    timeout?: number;
  }): Promise<void>;

  
  toBeEmpty(options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toBeEnabled(options?: {
    enabled?: boolean;

    
    timeout?: number;
  }): Promise<void>;

  
  toBeFocused(options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toBeHidden(options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toBeInViewport(options?: {
    
    ratio?: number;

    
    timeout?: number;
  }): Promise<void>;

  
  toBeVisible(options?: {
    
    timeout?: number;

    visible?: boolean;
  }): Promise<void>;

  
  toContainClass(expected: string|ReadonlyArray<string>, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toContainText(expected: string|RegExp|ReadonlyArray<string|RegExp>, options?: {
    
    ignoreCase?: boolean;

    
    timeout?: number;

    
    useInnerText?: boolean;
  }): Promise<void>;

  
  toHaveAccessibleDescription(description: string|RegExp, options?: {
    
    ignoreCase?: boolean;

    
    timeout?: number;
  }): Promise<void>;

  
  toHaveAccessibleErrorMessage(errorMessage: string|RegExp, options?: {
    
    ignoreCase?: boolean;

    
    timeout?: number;
  }): Promise<void>;

  
  toHaveAccessibleName(name: string|RegExp, options?: {
    
    ignoreCase?: boolean;

    
    timeout?: number;
  }): Promise<void>;

  
  toHaveAttribute(name: string, value: string|RegExp, options?: {
    
    ignoreCase?: boolean;

    
    timeout?: number;
  }): Promise<void>;

  
  toHaveAttribute(name: string, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toHaveClass(expected: string|RegExp|ReadonlyArray<string|RegExp>, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toHaveCount(count: number, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toHaveCSS(name: string, value: string|RegExp, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toHaveId(id: string|RegExp, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toHaveJSProperty(name: string, value: any, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toHaveRole(role: "alert"|"alertdialog"|"application"|"article"|"banner"|"blockquote"|"button"|"caption"|"cell"|"checkbox"|"code"|"columnheader"|"combobox"|"complementary"|"contentinfo"|"definition"|"deletion"|"dialog"|"directory"|"document"|"emphasis"|"feed"|"figure"|"form"|"generic"|"grid"|"gridcell"|"group"|"heading"|"img"|"insertion"|"link"|"list"|"listbox"|"listitem"|"log"|"main"|"marquee"|"math"|"meter"|"menu"|"menubar"|"menuitem"|"menuitemcheckbox"|"menuitemradio"|"navigation"|"none"|"note"|"option"|"paragraph"|"presentation"|"progressbar"|"radio"|"radiogroup"|"region"|"row"|"rowgroup"|"rowheader"|"scrollbar"|"search"|"searchbox"|"separator"|"slider"|"spinbutton"|"status"|"strong"|"subscript"|"superscript"|"switch"|"tab"|"table"|"tablist"|"tabpanel"|"term"|"textbox"|"time"|"timer"|"toolbar"|"tooltip"|"tree"|"treegrid"|"treeitem", options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toHaveScreenshot(name: string|ReadonlyArray<string>, options?: {
    
    animations?: "disabled"|"allow";

    
    caret?: "hide"|"initial";

    
    mask?: Array<Locator>;

    
    maskColor?: string;

    
    maxDiffPixelRatio?: number;

    
    maxDiffPixels?: number;

    
    omitBackground?: boolean;

    
    scale?: "css"|"device";

    
    stylePath?: string|Array<string>;

    
    threshold?: number;

    
    timeout?: number;
  }): Promise<void>;

  
  toHaveScreenshot(options?: {
    
    animations?: "disabled"|"allow";

    
    caret?: "hide"|"initial";

    
    mask?: Array<Locator>;

    
    maskColor?: string;

    
    maxDiffPixelRatio?: number;

    
    maxDiffPixels?: number;

    
    omitBackground?: boolean;

    
    scale?: "css"|"device";

    
    stylePath?: string|Array<string>;

    
    threshold?: number;

    
    timeout?: number;
  }): Promise<void>;

  
  toHaveText(expected: string|RegExp|ReadonlyArray<string|RegExp>, options?: {
    
    ignoreCase?: boolean;

    
    timeout?: number;

    
    useInnerText?: boolean;
  }): Promise<void>;

  
  toHaveValue(value: string|RegExp, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toHaveValues(values: ReadonlyArray<string|RegExp>, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toMatchAriaSnapshot(expected: string, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toMatchAriaSnapshot(options?: {
    
    name?: string;

    
    timeout?: number;
  }): Promise<void>;

  
  not: LocatorAssertions;
}


interface PageAssertions {
  
  toHaveScreenshot(name: string|ReadonlyArray<string>, options?: PageAssertionsToHaveScreenshotOptions): Promise<void>;

  
  toHaveScreenshot(options?: PageAssertionsToHaveScreenshotOptions): Promise<void>;

  
  toHaveTitle(titleOrRegExp: string|RegExp, options?: {
    
    timeout?: number;
  }): Promise<void>;

  
  toHaveURL(url: string|RegExp|((url: URL) => boolean), options?: {
    
    ignoreCase?: boolean;

    
    timeout?: number;
  }): Promise<void>;

  
  not: PageAssertions;
}


interface SnapshotAssertions {
  
  toMatchSnapshot(name: string|ReadonlyArray<string>, options?: {
    
    maxDiffPixelRatio?: number;

    
    maxDiffPixels?: number;

    
    threshold?: number;
  }): void;

  
  toMatchSnapshot(options?: {
    
    maxDiffPixelRatio?: number;

    
    maxDiffPixels?: number;

    
    name?: string|Array<string>;

    
    threshold?: number;
  }): void;
}


export interface Location {
  
  column: number;

  
  file: string;

  
  line: number;
}


export interface TestInfoError {
  
  cause?: TestInfoError;

  
  message?: string;

  
  stack?: string;

  
  value?: string;
}


export interface TestStepInfo {
  
  attach(name: string, options?: {
    
    body?: string|Buffer;

    
    contentType?: string;

    
    path?: string;
  }): Promise<void>;

  
  skip(): void;

  
  skip(condition: boolean, description?: string): void;

  
  titlePath: Array<string>;
}


export interface WorkerInfo {
  
  config: FullConfig;

  
  parallelIndex: number;

  
  project: FullProject;

  
  workerIndex: number;
}

export interface PageAssertionsToHaveScreenshotOptions {
  
  animations?: "disabled"|"allow";

  
  caret?: "hide"|"initial";

  
  clip?: {
    
    x: number;

    
    y: number;

    
    width: number;

    
    height: number;
  };

  
  fullPage?: boolean;

  
  mask?: Array<Locator>;

  
  maskColor?: string;

  
  maxDiffPixelRatio?: number;

  
  maxDiffPixels?: number;

  
  omitBackground?: boolean;

  
  scale?: "css"|"device";

  
  stylePath?: string|Array<string>;

  
  threshold?: number;

  
  timeout?: number;
}

interface TestConfigWebServer {
  
  command: string;

  
  cwd?: string;

  
  env?: { [key: string]: string; };

  
  gracefulShutdown?: {
    signal: "SIGINT"|"SIGTERM";

    timeout: number;
  };

  
  ignoreHTTPSErrors?: boolean;

  
  name?: string;

  
  port?: number;

  
  reuseExistingServer?: boolean;

  
  stderr?: "pipe"|"ignore";

  
  stdout?: "pipe"|"ignore";

  
  timeout?: number;

  
  url?: string;
}

